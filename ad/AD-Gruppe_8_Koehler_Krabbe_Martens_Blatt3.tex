\documentclass[10pt,a4paper,oneside,ngerman,numbers=noenddot]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bytefield}
\usepackage{paralist}
\usepackage{gauss}
\usepackage{pgfplots}
\usepackage{textcomp}
\usepackage[locale=DE,exponent-product=\cdot,detect-all]{siunitx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}
\usetikzlibrary{automata,matrix,fadings,calc,positioning,decorations.pathreplacing,arrows,decorations.markings}
\usepackage{polynom}
\polyset{style=C, div=:,vars=x}
\pgfplotsset{compat=1.8}
\pagenumbering{arabic}
\def\thesection{\arabic{section})}
\def\thesubsection{(\alph{subsection})}
\def\thesubsubsection{(\roman{subsubsection})}
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother
\parskip 12pt plus 1pt minus 1pt
\parindent 0pt

\begin{document}
\author{Reinhard Köhler (6425686), Tronje Krabbe (6435002), \\
Jim Martens (6420323)}
\title{Hausaufgaben zum 20. November}
\subtitle{Gruppe 8}
\maketitle
\section{} %1
	\subsection{} %a
		$11\mathbb{N}+10$
		Auf der letzten Position liegen alle Zahlen, die um 10 größer sind, als die nächstkleinere durch 11 teilbare Zahl. Dies ist offensichtlich bei der gegebenen Hashfunktion. 
	\subsection{} %b
		$11\mathbb{N}+5$
		Auf der letzten Position liegen alle Zahlen, die um 5 größer sind, als die nächstkleinere durch 11 teilbare Zahl. Dies ergibt sich aus a) dadurch, dass jetzt $k$ mit 2 multipliziert wird, womit die Wert nur noch um 5 größer sein können.
	\subsection{} %c
		$\sqrt{11\mathbb{N}}$
		Die gegebene Hashfunktion ist nicht eindeutig von dem Bezug des Modulo her. Da es wenig Sinn macht die Bedeutung $k^{2} + (10 \mod 11)$ anzunehmen, sind wir von der Bedeutung $(k^{2} + 10) \mod 11$ ausgegangen. In dieser zweiten Bedeutung muss $k^{2}$ also immer einem Vielfachen von $11$ entsprechen. Ein Vielfaches von $11$ wird mit $11\mathbb{N}$ ausgedrückt. Da jedoch nicht $k$ dort steht, sondern $k^{2}$ ist die Menge aller Keys $\sqrt{11\mathbb{N}}$.
	\subsection{} %d
		$(\log_{3}11)\mathbb{N} + \log_{3}11$
		Die gegebene Hashfunktion ist nicht eindeutig von dem Bezug des Modulo her. Da es wenig Sinn macht die Bedeutung $3^{k}- (1 \mod 11)$ anzunehmen, sind wir von der Bedeutung $(3^{k}-1) \mod 11$ ausgegangen. In dieser zweiten Bedeutung muss $3^{k}$ einem Vielfachen von $11$ entsprechen. Der Schlüssel hierzu ist, was der Exponent von $3$ sein muss, um $11$ zu ergeben. Das Ergebnis ist $\log_{3}11$. Da $\mathbb{N}$ die $0$ mit einschließt, ergibt sich diese Menge aller Keys $(\log_{3}11)\mathbb{N} + \log_{3}11$.
\section{} %2
	Zu Beginn wird $n!$ mit $n^{n}$ verglichen.
	\[
		\frac{n \cdot n \cdot n \cdot \text{...} \cdot n \cdot n}{n \cdot (n-1) \cdot (n-2) \cdot \text{...} \cdot 2 \cdot 1}
	\]
	Es wird deutlich, dass $n!$ asymptotisch langsamer wächst als $n^{n}$. Anschließend vergleichen wir $n!$ mit $\left(\frac{n}{2}\right)^{\frac{n}{2}}$.
	\[
		\frac{n \cdot (n-1) \cdot (n-2) \cdot ... \cdot (n- \frac{n}{2}) \cdot (n - \frac{n}{2} - 1) \cdot ... \cdot 2 \cdot 1}{\frac{n}{2} \cdot \frac{n}{2} \cdot \frac{n}{2} \cdot ... \frac{n}{2} \cdot 1 \cdot ... \cdot 1 \cdot 1}
	\]
	Es wird deutlich, dass $n!$ asymptotisch schneller wächst als $\left(\frac{n}{2}\right)^{\frac{n}{2}}$.
	
	Aufgrund dieser Feststellungen wird nun der Logarithmus von $\left(\frac{n}{2}\right)^{\frac{n}{2}}$ und $n^{n}$ gebildet und mit dem von $n!$ verglichen.
	\begin{alignat*}{2}
		\log\left(\left(\frac{n}{2}\right)^{\frac{n}{2}}\right) &=& \frac{n}{2} \log\left(\frac{n}{2}\right) \\
		&=& \frac{1}{2}n \log\left(\frac{1}{2}n\right) \\
		\log(n^{n}) &=& n \log n
	\end{alignat*}
	Damit ist klar, dass die Logarithmen von $\left(\frac{n}{2}\right)^{\frac{n}{2}}$ und $n^{n}$ beide in $\theta(n \log n)$ sind. Aus unserem obigen Vergleich wissen wir, dass $n!$ schneller als $\left(\frac{n}{2}\right)^{\frac{n}{2}}$ und langsamer als $n^{n}$ wächst. Daraus ergibt sich:
	\[
		\frac{1}{2}n\log(\frac{1}{2}n) \in \theta(n \log n) \leq \log(n!) \leq n \log n \in \theta(n \log n)
	\]
	Da $\log(n!)$ asymptotisch sowohl schneller als auch langsamer als $n \log n$ wachsen muss, liegt $\log(n!)$ damit folgerichtig in $\theta(n \log n)$.
\section{} %3
	\subsection{} %a
		\begin{alignat*}{2}
			T(1) &=& 1 \\
			T(n) &=& 2T\left(\frac{n}{2}\right) + \mathcal{O}(n^{2})
		\end{alignat*}
		Anhand des Mastertheorems ergibt sich, dass $\mathcal{O}(n^{2})$ eine scharfe Schranke für die worst-case Laufzeit von dieser Quicksort-Variante ist.
	\subsection{} %b
		Diese Variante wird in der Praxis meist nicht verwendet, weil die benötigte Zeit zum Finden des Medians die Zeitersparnis beim Aufspalten bei weitem nicht rechtfertigt. Je größer die Eingabe wird und je weiter die einzelnen Zahlen auseinander liegen, desto länger dauert das Ermitteln des Medians.
	\subsection{} %c
\section{} %4
	\subsection{} %a
		\begin{verbatim}
			function RANDOM(k):
			    string bitmask = '';
			    for (int i = 0; i < k; i++):
			        bitmask += (string) werfeMuenze();
			    end for
			    
			    if bitmask.isEmpty():
			        return A[0];
			    endif
			    
			    int index = stringToBinary(bitmask);
			    return A[index];
			end function
		\end{verbatim}
		Nach $k$-maligem Werfen einer Münze ergibt sich eine Zahl mit $k$ Bits. Die größte darstellbare Index ist damit $2^{k}$, wodurch alle Elemente des Arrays abgedeckt werden können. Da bei dem Münzwurf die $0$ und die $1$ gleich wahrscheinlich sind, ergibt sich nach $k$-maligem Werfen somit eine Gesamtwahrscheinlichkeit für den Index von $\frac{1}{2^{k}}$. Somit wird jedes Element des Arrays mit der gleichen Wahrscheinlichkeit von der Funktion zurückgegeben. Hat das Array nur ein Element, dann wird auch immer dieses Element zurückgegeben.
		
		Da immer $k$-Mal eine Münze geworfen wird, ist die Anzahl nötiger Münzwürfe auch immer in $\mathcal{O}(\log n)$. Dies ergibt sich so:
		\[
			\mathcal{O}(\log n) = \mathcal{O}(\log(2^{k})) = \mathcal{O}(k \cdot \log 2) = \mathcal{O}(k)
		\]
		Da $\log 2$ eine Konstante ist, ist sie bei der Betrachtung der asymptotischen Laufzeit irrelevant. Damit ist nun auch gezeigt, dass die Anzahl nötiger Wünzwürfe $\mathcal{O}(\log n)$ garantiert.
	\subsection{} %b
		Die Lösung von (a) kann man sich auch als vollen binären Baum vorstellen. Es wird an jedem Knoten eine Münze geworfen, und dann entsprechend entlang des Baumes weitergegangen. Auf Ebene $k$ wurde eine Binärzahl mit Länge $k$, also innerhalb des Intervalls $[0, 2^k]$ generiert. \\
        Ist $n$ keine Zweierpotenz, so kann kein voller Baum mehr benutzt werden, um dieses Problem zu lösen. Es muss also ein vollständiger Baum genügen. Dieser hat immernoch eine maximale Tiefe von $(\log n)$ sowie eine Münzwurfanzahl von $\mathcal{O}(\log n)$, da maximal $\lceil (\log_2 n) \rceil$-mal geworfen werden muss. Für einige Elemente des Arrays wird allerdings ein Münzwurf weniger benötigt.
	\subsection{} %c
\section{} %5
	\subsection{} %a
		\begin{tikzpicture}[shorten >=1pt,node distance=2.8cm,on grid]
			\node[state] (bleqc) {$b \leq c$};
			\node[state] (aleqb) [below left=2 and 3 of bleqc] {$a \leq b$};
			\node[state] (aleqc) [below right=2 and 3 of bleqc] {$a \leq c$};
			\node[state] (aleqc2) [below right=of aleqb] {$a \leq c$};
			\node[state] (aleqb2) [below right=of aleqc] {$a \leq b$};
			\node (res1) [below left=of aleqb] {$a, b, c$};
			\node (res2) [below left=of aleqc2] {$b, a, c$};	
			\node (res3) [below right=of aleqc2] {$b, c, a$};
			\node (res4) [below left=of aleqc] {$a, c, b$};
			\node (res5) [below left=of aleqb2] {$c, a, b$};
			\node (res6) [below right=of aleqb2] {$c, b, a$};
			
			\path[every node/.style={font=\scriptsize}] 
				(bleqc) edge node [below right=0 and 0.45 of bleqc] {Nein} (aleqc)
				(bleqc) edge node [below left=0 and 0.3 of bleqc] {Ja} (aleqb)
				(aleqb) edge node [below left=0 and 0.3 of aleqb] {Ja} (res1)
				(aleqb) edge node [below right=0 and 0.45 of aleqb] {Nein} (aleqc2)
				(aleqc) edge node [below left=0 and 0.3 of aleqc] {Ja} (res4)
				(aleqc) edge node [below right=0 and 0.45 of aleqc] {Nein} (aleqb2)
				(aleqc2) edge node [below left=0 and 0.3 of aleqc2] {Ja} (res2)
				(aleqc2) edge node [below right=0 and 0.45 of aleqc2] {Nein} (res3)
				(aleqb2) edge node [below left=0 and 0.3 of aleqb2] {Ja} (res5)
				(aleqb2) edge node [below right=0 and 0.45 of aleqb2] {Nein} (res6);
		\end{tikzpicture}
	\subsection{} %b
		Wenn das Eingabearray a, b, c und d enthielte, dann hätte der Baum 24 Blätter, also $4!$. Wenn das Eingabearray alle Buchstaben von a bis z enthielte, dann hätte der Baum $26!$ Blätter.
\end{document}
