\documentclass[10pt,a4paper,oneside,ngerman,numbers=noenddot]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bytefield}
\usepackage{paralist}
\usepackage{gauss}
\usepackage{pgfplots}
\usepackage{textcomp}
\usepackage[locale=DE,exponent-product=\cdot,detect-all]{siunitx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}
\usetikzlibrary{automata,matrix,fadings,calc,positioning,decorations.pathreplacing,arrows,decorations.markings}
\usepackage{polynom}
\polyset{style=C, div=:,vars=x}
\pgfplotsset{compat=1.8}
\pagenumbering{arabic}
\def\thesection{\arabic{section})}
\def\thesubsection{(\alph{subsection})}
\def\thesubsubsection{(\roman{subsubsection})}
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother
\parskip 12pt plus 1pt minus 1pt
\parindent 0pt

\begin{document}
\author{Reinhard Köhler (6425686), Tronje Krabbe (6435002), \\
Jim Martens (6420323)}
\title{Hausaufgaben zum 4. Dezember}
\subtitle{Gruppe 8}
\maketitle
\section{} %1
	\subsection{} %a
		Der Algorithmus funktioniert nicht weiterhin. Dies wird anhand dieses Gegenbeispiels deutlich:
		
		\begin{verbatim}
		    A = [0,1,4,8,10,13]
		    value = 1
		    low = 0
		    high = 5
		    // erster Schleifendurchlauf 0 < 5, daher Rumpf ausführen
		    mid = (0 + 5) / 2 = 2
		    // A[2] = 4 > value
		    high = 2 - 1 = 1
		    // zweiter Schleifendurchlauf 0 < 1, daher Rumpf ausführen
		    mid = (0 + 1) / 2 = 0
		    // A[0] = 0 < value
		    low = 0 + 1 = 1
		    // dritter Schleifendurchlauf 1 = 1, daher Rumpf nicht ausführen
		    return not_found
		\end{verbatim}
		
		Obwohl das Element vorhanden ist, wird zurückgegeben, dass es nicht vorhanden sei. Da es ein Gegenbeispiel gibt, funktioniert der Algorithmus nach der Änderung von \texttt{while (low <= high)} zu \texttt{while (low < high)} nicht mehr.
	\subsection{} %b
		\begin{verbatim}
		    BinarySearch(A[0..N-1], value) {
		        low = N - 1
		        high = 0
		        while (high <= low) {
		            // invariants: value > A[i] for all i < low
		                           value < A[i] for all i > high
		            mid = (low + high) / 2
		            if (A[mid] > value)
		                high = mid + 1
		            else if (A[mid] < value)
		                low = mid - 1
		            else
		                return mid
		        }
		        return not_found
		    }
		\end{verbatim}
	\subsection{} %c
		\textbf{Formaler Beweis:} Wir müssen beweisen, dass die while-Schleife endet. Angenommen wir befinden uns in Iteration $i$ der while-Schleife.
		\begin{itemize}
			\item	Zu Beginn der while-Schleife haben wir \texttt{high $\leq$ low} (andernfalls hätten wir die while-Schleife nicht betreten).
			\item	Nach dem Ausdruck \texttt{mid = (low + high) / 2} gilt \texttt{high $\leq$ mid $\leq$ low}.
			\item	Entweder die Schleife wird durch die Rückgabe von \texttt{mid} beendet, womit wir fertig wären.
			\item	Oder sie befindet sich in einer der ersten beiden Fälle des if-Statements. Entweder high wird um mindestens eins erhöht oder low wird um mindestens eins verkleinert, wodurch sich in jedem Schleifendurchlauf die Differenz von \texttt{low - high} um mindestens eins verringert.
			\item	Damit gilt \texttt{low - high < 0} nach maximal $n$ Iterationen der while-Schleife und die Schleife terminiert.
		\end{itemize}
	\subsection{} %d
		\textbf{Beweis der Korrektheit:}
		
		Offensichtlich gibt der Algorithmus ein korrektes Ergebnis zurück, wenn \texttt{mid} zurückgegeben wird, da dann \texttt{A[mid] $=$ value} gilt.
		
		Zu zeigen: Wenn der Algorithmus \texttt{not\_found} zurückgibt, dann kommt \texttt{value} tatsächlich nicht in dem Array vor.
		
		Wir werden dies nun durch die Gegenposition beweisen: Wir müssen zeigen, dass wenn \texttt{value} im Array vorkommt, der Algorithmus \texttt{mid} zurückgibt.
		
		\textbf{Erster Schritt:} Es ist einfach zu sehen, dass die folgenden Invarianten immer gelten:
		\begin{itemize}
			\item	\texttt{value > A[i] for all i < low (strict inequality!)}
			\item	\texttt{value < A[i] for all i > high (strict inequality!)}
		\end{itemize}
		
		\textbf{Zweiter Schritt:} Annahme, dass \texttt{value} im Array vorkommt.
		\begin{itemize}
			\item	Bereits bekannt: Invarianten sind wahr. Das bedeutet zu keinem Zeitpunkt im Algorithmus kann sich das Element, das wir suchen, links von \texttt{high} oder rechts von \texttt{low} befinden.
			\item	Der einzige Weg, wie wir theoretisch das gesuchte Element "`verpassen"' könnten, wäre, dass \texttt{high = mid + 1} oder \texttt{low = mid - 1} zu der Situation führen, dass \texttt{high > low} gilt bevor wir das gesuchte Element gefunden haben (weil wir dann die Schleife verlassen).
			\begin{itemize}
				\item	Durch die Konstruktion des Algorithmus haben wir immer \texttt{high $\leq$ mid $\leq$ low} nachdem \texttt{mid = (low + high) / 2} ausgeführt wurde.
				\item	Solange \texttt{low $\geq$ high + 2} gilt, haben wir immer \texttt{high < mid < low}.
				In dieser Situation, \texttt{mid - 1 $\geq$ high} und \texttt{mid + 1 $\leq$ low}, haben wir immer noch \texttt{high $\leq$ low} nachdem entweder \texttt{high = mid + 1} oder \texttt{low = mid - 1} ausgeführt wurden, sodass die while-Schleife ein weiteres Mal betreten wird.

				Es gibt zwei kritische Fälle, in denen wir die Schleife verlassen könnten:
				\begin{itemize}
					\item	\texttt{low = high}. Aber dann gilt auch \texttt{mid = high}. Nach der Annahme, dass \texttt{value} im Array ist, muss \texttt{A[high] = value} gelten. Durch die Rückgabe von \texttt{mid} wird demnach genau der richtige Index zurückgegeben.
					\item	\texttt{low = high + 1}. In diesem Fall gilt \texttt{mid = high}. Nun gilt entweder \texttt{A[high] = A[mid] = value}, wodurch durch Rückgabe von \texttt{mid} das richtige Ergebnis zurückgegeben würde, oder es gilt \texttt{A[high] = A[mid] > value}, wodurch \texttt{high} um eins erhöht würde, was beim nächsten Schleifendurchlauf im Fall \texttt{low = high} enden würde. In dem Fall wird das korrekte Ergebnis zurückgegeben, wie bereits gezeigt wurde.
				\end{itemize}
			\end{itemize}
			\item	Dies zeigt, dass wenn \texttt{value} im Array vorhanden ist, der Algorithmus immer damit endet \texttt{mid} zurückzugeben.
		\end{itemize}
\section{} %2
	\subsection{} %a
		\subsubsection{} %i
			In einem Graph ohne Kanten kann jeder Knoten gleich gefärbt sein. Dies gilt, weil die Bedingung $c_{k}(i= \neq c_{k}(j)$ nur gilt, wenn $i$ und $j$ mit einer Kante verbunden sind, was in solch einem Graphen nicht gegeben ist. Daher ist hier nichts zu zeigen.
		\subsubsection{} %ii
			Wenn ein Graph k-färbbar ist, dann kann man auch eine weitere Farbe in die Abbildung $c_{k}$ hinzunehmen ohne sie zu benutzen. Dies gilt da $c_{k}$ nicht surjektiv sein muss.
		\subsubsection{} %iii
			Man nehme einen k-färbbaren Graphen. Nun kann man solange weitere Farben hinzufügen, bis n Farben in der Abbildung vorkommen. Diese müssen jedoch nicht benutzt werden. Daher ist jeder Graph n-färbbar.
	\subsection{} %b
		\subsubsection{} %i
			Wenn ein Graph 2-färbbar ist, dann gibt es keine Zyklen ungerader Länge. Bei einem Zyklus gerader Länge kann jeder zweiter Knoten die gleiche Farbe haben, ohne mit einem Knoten verbunden zu sein, der die gleiche Farbe hat.
			
			Alle Knoten mit einer Farbe kann man als eine Untermenge einer Abbildung eines bipartiten Graphen verstehen.
		\subsubsection{} %ii
			\begin{verbatim}
			    IST_2FAERBUNG(G) {
			        // todo: make this algorithm
			    }
			\end{verbatim}
		\subsubsection{} %iii
			Es gibt 2 verschiedene 2-Färbungen, sofern man unterschiedliche Farben nicht als Unterschied ansieht. Pro 2 Farben gibt es genau 2 verschiedene Färbungen.
	\subsection{} %c
		Bei einer beliebigen Landkarten, überführt in einen Graphen, werden mindestens so viele Farben benötigt, wie der kürzeste Zyklus ist.
		\subsubsection{} %i
			\begin{tikzpicture}
				\node (altona) {A};
				\node (eimsbuettel) [above right=of altona] {E};
				\node (nord) [right=of eimsbuettel] {N};
				\node (wandsbek) [right=of nord] {W};
				\node (mitte) [below=of eimsbuettel] {M};
				\node (harburg) [below left=of mitte] {H};
				\node (bergedorf) [below right=of mitte] {B};
				
				\path[every node/.style={font=\scriptsize}] 
					(altona) edge (mitte)
					(altona) edge (eimsbuettel)
					(mitte) edge (harburg)
					(mitte) edge (bergedorf)
					(mitte) edge (eimsbuettel)
					(mitte) edge (nord)
					(mitte) edge (wandsbek)
					(eimsbuettel) edge (nord)
					(nord) edge (wandsbek);
			\end{tikzpicture}
		\subsubsection{} %ii
			\begin{alignat*}{2}
				c_{k}(A) &=& gelb \\
				c_{k}(E) &=& rot \\
				c_{k}(M) &=& blau \\
				c_{k}(H) &=& rot \\
				c_{k}(B) &=& rot \\
				c_{k}(N) &=& gelb \\
				c_{k}(W) &=& rot
			\end{alignat*}
		\subsubsection{} %iii
			
		\subsubsection{} %iv
			\begin{tikzpicture}
				\node (sh) {SH};
				\node (hh) [below right=of sh] {HH};
				\node (meck) [right=of hh] {MP};
				\node (bremen) [below left=of hh] {B};
				\node (nieder) [below=of hh] {N};
				
				\path[every node/.style={font=\scriptsize}] 
					(sh) edge (hh)
					(sh) edge (meck)
					(hh) edge (nieder)
					(bremen) edge (nieder)
					(sh) edge (nieder)
					(bremen) edge (sh)
					(bremen) edge (hh);
			\end{tikzpicture}
			
			In dieser konstruierten Karte (dargestellt als Graph), müssen mindestens vier Farben verwendet werden.
\section{} %3
	\subsection{} %a
	\subsection{} %b
	\subsection{} %c
	\subsection{} %d
	\subsection{} %e
	\subsection{} %f
\section{} %4
	\subsection{} %a
	\subsection{} %b
	\subsection{} %c
\end{document}
